---
layout: post
title: "언어의 탄생 #1: C 그리고 포인터"
author: Chang W. Doh
date:   2014-07-05 00:00:00
categories: html5
description: "포인터는 C를 처음 시작하는 개발자들이 가장 많이 질문하는 주제입니다. 질문에 대한 답변은 주로 사용례로 그치지만 사실 기저에 깔려있는 조금 더 깊은 몇가지 내용들이 필요합니다. 이 글에서는 가상으로 C가 어떻게 발생했고 왜 포인터는 그렇게 생겼는지를 알아보도록 하겠습니다."
published: false
---

##

### 예: 바이너리 코드 vs. 헥사 코드 vs. 어셈블리 코드

어셈블리는 머신에서 실행되는 바이너리 코드를 1:1 동치 관계에 있는 간략한 문법으로 표현하여 특히 초기 컴퓨팅 환경에서 단지 읽을만하다는 점 하나로도 획기적인 발전을 가져온 발명(?)이었다.

아래는 위키피디아의 [어셈블리 언어](http://en.wikipedia.org/wiki/Assembly_language#Assembly_language)에서 발췌한 내용으로 x86/IA-32 머신에서 레지스터에 1바이트 정수값 97을 로드하는 코드의 기계어 표현이다.

    10110000 01100001

그러나 1과 0이 무한 반복되면 읽기가 쉽지가 않다. 그래서 이를 16진수로 표현해본다.

    B0 61

보다시피 최소한 10110000보다는 B0가 기억하기 쉽다. 여기서 B0는 명령에 해당하고 61은 데이터에 해당하는데 코드가 길어지고 중간에 인덱스를 한번이라도 놓치면 헬게이트가 열린다. 예를 들어 아래 코드는 1바이트 정수 176을 로드하는 코드이다.

    B0 B0

어느 것이 명령이고 어느 것이 데이터인가? 물론 한 줄이라서 괜찮겠지만 이게 계속 이어진다면? 한참 코드 읽고 있는데 누가 툭 치면서 점심이라도 먹으러 가자거나 하면 스트레스가 초신성마냥 폭팔할 수도 있을 것이다. 그래서 이를 참지못한 사람들은 어느 정도 가독성(Readability)이 보장되는 어셈블리를 만들기에 이른다. :)

    MOV AL, 61h       ; Load AL with 97 decimal (61 hex)

위의 코드는 최소한 명령어와 데이터는 구분이 간다. 이는 아래 코드와 같이 좀 더 길어지면 그 효용성은 극명해진다.

    Binary Code:
      10110000 00000001 10110001 00000002 10110011 00000003

    Hexa Code:
      B0 01 B1 02 B3 03

    Assemble Code:
      MOV AL, 1h
      MOV CL, 2h
      MOV DL, 3h

위의 예에서는 명령어에 의한 데이터 영역의 길이가 일정했지만 실제 명령어 셋들을 보면 데이터의 길이가 유동적이기 때문에 가뜩이나 울고 싶은데 빰까지 때리는 수준으로 변한다. :(

> 이에 대한 좀 더 자세한 내용은 (아마도) 다음 포스트의 주제인 `코드, 메모리 그리고 C 포인터`에서 다루도록 하겠습니다.

프로그래밍 언어의 목적은 다양하지만 밑으로 내려가고 내려가고 하다보면 결국 그 목적을 위해 `데이터`를 다루는 방법인 `명령어`로 귀결된다.

예를 들자면 `기계어`로 표출된 코드를 좀 더 사용자가 쉽게 이해할 수 있도록 하기 위해 `어셈블리`가 고안되었고 타겟 머신에 의존적이지 않 보다 일반적인 코드의 서술을 위해 `C`와 같은 언어가 정의되었으며 이와는 별개로 `객체` 간의 상호작용을 기반으로 프로그램을 설계하기 위해 객체 지향이라는 개념을 다루기 위한 `Smalltalk`, `C++`, `Java` 등의 언어가 발생했다.

> 참고로 객체지향 언어가 이후에 나왔다는 뜻은 아니다. 객체 지향에 대한 개념은 컴퓨팅 언어의 역사에서도 굉장히 빠르게 나온 개념이고 이를 구체화한 언어도 50년대에 이미 개발된 상태였다.
