---
layout: post
title: "프로그래밍을 시작하는 그대에게 :)"
date:   2014-06-24 00:00:00
categories: DeveloperLife
description: "프로그래밍은 전문적인 영역이면서 한편으로는 쉽게 접근할 수 있는 양면성을 가지고 있어 처음 프로그래밍을 배운 분들이 다음 단계로 넘어가는데 어려움을 느끼기도 합니다. 이 글은 프로그래밍에 대한 개인적인 경험으로 학교 후배들에게 해주고 싶었던 이야기를 정리해 보았습니다."
published: true
---

[toc]

이 포스트는 프로그래밍을 막 시작한 분들에게 프로그래밍 관련 질문을 받고 답변을 하면서 지극히 개인적인 생각들을 프로그래밍을 막 시작한 분들에게 도움이 될까 싶어 정리한 포스트이며 "필요성 관점에서 보는 프로그래밍 언어 워크숍"을 위한 기초 자료이기도 합니다. 따라서 **당연한 내용들로 점철되어 있겠지만** 첨언해주실 내용이 있다면 즐겁게 받겠습니다. :)

## 프로그래밍 언어를 익히는 것은 왜 어려울까?

개발자를 꿈꾸는 학생들이 질문하는 상황은 대부분 아래에서 크게 벗어나지 않았습니다.

> 대학생 프밍군은 어렸을 적부터 꿈이었던 멋진 게임 개발자가 되기 위해 프로그래밍 세계에 뛰어들기로 합니다. 인터넷도 뒤져보고 프로그래밍 책도 사보고 나름 책 한권을 떼었다고 생각했지만 프로그래밍을 어떻게 해야할 지는 눈에 보이지 않았다. 간단한 프로그램을 작성해보기로 했지만 이 역시 어디에서 시작해야 할지 막막했다.

개발 커뮤니티라면 어느 곳에서든지 쉽게 질문을 접할 수 있는 상황이기도 하고 오늘 포스트에서 이야기하고자 하는 바도 여기에서 출발했습니다.


### 초보자가 프로그래밍을 시작하는 것이 어려운 것은 당연하다.

한동안 영어 수업을 받으면서 선생님들이 내게 공통적으로 지적하는 얘기가 있었습니다.

> "Chang, 영어권에서는 중요한 얘기를 앞에 하고 보충 설명이 되는 부분은 뒤에 붙이는게 일반적이에요. 하지만 Chang은 말하고 싶은 주제를 계속 뒤에서 하네요. 틀렸다고 볼 수는 없지만 어색해요."

왜 이런 얘기를 들었을까요? 가장 먼저 떠오르는 것은 현재의 내가 가진 사고 방식이 영어권의 그것과는 다르기 때문입니다. 즉, 모든 대화에는 문맥(Context)이 있기 마련인데 내 경우에는 뜻은 전달하지만 문장의 흐름이 다르다는 뜻이기도 합니다.

같은 관점에서 문법과 간단한 활용 예제를 다루는 책 한권으로 언어 하나를 잘 다루는 것은 매우 어렵습니다. 언어라는 카테고리에서 다시 이야기를 해보자면 어떤 언어를 익힌다는 것은 그 언어를 사용하여 커뮤니케이션이 발전하는 프로세스 속에 존재합니다. 프로그래밍 역시 문법을 익히는 과정이 아니라 언어를 사용하는 과정이며 그 결과가 바로 코드이며 프로그램입니다.


#### 문법은 중요하지만 전부는 아니다.

일반적으로 프로그래밍 언어와 관련된 책들은 보통 문법과 각 문법의 사용 예제들 그리고 예제에서 사용자가 논리를 표출하기 위한 시스템의 프레임워크/라이브러리 등에 대한 **일부의 설명**을 포함합니다. 중요한 것은 이 책들은 언어의 표현 방법을 알려주는 것이 목적이지 프로그래밍 그 자체가 아닐 것이라는 점입니다.

> 물론 그러한 부분까지 다루는 책들도 많지만 아마 두꺼워서 읽지 않고 필요할 때 분들이 훨씬 많을 것입니다. :-)

아기들은 언어를 실제적인 사용례를 다양한 방식으로 입력받고 이를 표출하고 끊임없어 고쳐지는 환경에서 학습합니다. 몇년 후 아이는 가정이라는 공간 내에서 자신이 이야기하고자 하는 바를 상당히 잘 전달할 수 있게 됩니다. 그리고 학교와 사회 등의 다양한 환경을 접하며 다시 적합한 사용 방법을 직/간접적으로 교정받으며 언어 사용의 범주를 확장하게 됩니다. 프로그래밍 언어 역시 동일합니다.

> 그리고 아마도 프로그래밍이 좋은(?) 점은 아기는 우리가 바쁠 때에도 피드백을 전달하지만 우리가 접하는 (특히 현대적인) 개발 환경은 우리가 필요할 때 틀린 사용 방식(예를 들어 문법)은 틀렸다고 바로 말해준다는 점입니다. 물론 사랑스럽지는 않겠지만요. :)


#### 언어가 코드를 만들어주지는 않는다.

프로그래밍을 한다는 것은 영어로 에세이를 쓰는 것이고 편지를 쓰는 것이며 시를 쓰는 것과 같습니다. 에세이는 내 이야기를 상대방에게 전달하는 것이고, 편지는 누군가에게 얘기를 하는 것이고, 시는 감성을 누군가에게 전달합니다. 결국 **누군가(환경)**에게 **이야기(코드)**를 하기 위한 사고의 훈련이 필요하고 이는 언어와는 별개의 문제입니다.

커뮤니티들에서 자주 보는 또 다른 질문과 그에 대한 답변 패턴이 있습니다.

> **Q. "Java 책을 다 봤는데요. 다음은 어떤 언어를 익히는 것이 좋을까요?"<br/>**
>> A. "최근에는 Swift가 뜨는 것 같은데요. 이걸 공부해보는 것은 어떨까요?"<br/>
>> A. "알고리즘과 자료구조를 공부하세요."<br/>
>> A. "영어요."

몇년 동안 영어를 배웠어도 실생활에서 쓰지 못하는 것이 일본어나 중국어를 배우지 않아서는 아닐 것입니다. 물론 위의 답변들도 상황에 따라 적절한 답변이 될 수도 있고 다양한 언어를 익히는 것은 오히려 추천해주고 싶긴 하지만 최소한 이 시점에서 다른 언어 배우기가 이 친구가 해야할 것은 아닙니다.

> 우리가 배워야 하는 것은 언어만은 아닙니다.<br/>
> ![Textbooks for Programming languages](http://upload.wikimedia.org/wikipedia/commons/thumb/1/19/Bangalore_India_Tech_books_for_sale_IMG_5261.jpg/480px-Bangalore_India_Tech_books_for_sale_IMG_5261.jpg)<br/>
> Source: [Wikipedia - Programming Language](http://en.wikipedia.org/wiki/Programming_language)

언어가 코드를 만들어주지 않습니다. 코드를 만드는 것은 언어의 사용자 자신입니다. 공학은 어떠한 원리들을 결합해서 목적하는 기능을 달성하는데 있으므로 원리에 대한 이해도 중요하지만 이를 응용하여 목적에 도달하는 사고 방식의 훈련이 필요하며 따라서 틀린 코드라도 기술해가면서 프로그램을 작성하는 과정이 필요합니다. 결국 프로그래밍을 빠르게 체득해보고 싶다면 본인의 **사고 방식과 잘 맞는 환경에서 흥미로운 주제의 코드를 작성**하는 것이 가장 쉽습니다.

따라서 이 시점에 필요한 것은 **'어떤 것이라도 돌아가는 코드를 작성해보세요.'**라는 대답입니다. 유행, 자료구조, 알고리즘 그 어떤 것도 다음 단계에나 존재합니다.

> 보면 안다는 말이 때로는 틀리지 않겠지만 이는 이전의 충분한 경험으로부터 많은 부분이 재활용될 수 있는 그 무엇이거나 정말 천재가 할 수 있는 범주에 속한 것입니다. 일반적인 경우는 보고 연습하고 체화하는 과정이 필요합니다. 천재와 경쟁할 필요가 없고 당장 없는 경험을 만들어 낼 수도 없으니 천천히 가다보면 언젠가는 남들이 배우는 속도 또한 크게 다르지 않다고 느끼게 될 것입니다. :)


## 어떻게 접근할까

오늘 날에는 책, 강의, 온라인 등의 다양한 매체를 통해 프로그래밍 언어를 익히기 위한 충분한 자료를 얻을 수 있습니다. 반대로 말하자면 읽을거리는 매우 많습니다. 게다가 모든 것을 다 읽고 공부할 필요도 없습니다. 당연한 얘기지만 **개인의 상태, 학습 속도 그리고 성향에 따라 맞추어가는 방식**을 찾는게 더 중요합니다. 모두에게 맞는 방법은 아니겠지만 비슷한 상황 하에 계신 분에게는 도움이 되리라 믿으며 아래에서 개인적인 경험에 기반하여 언어에 접근하는 방법을 설명하고자 합니다.

### 관념적인 접근은 인간의 영역

인간의 언어는 기본적으로 열려있는 문맥(Context)을 지향합니다. 이는 관념적인 접근이며 바꿔말하자면 우리가 언어로 소통을 할 때 모든 것이 개개인이 가진 관념에 따라 문맥이 해석된다는 뜻입니다. '대화'에서 '오류'의 발생은 매우 일상적입니다. 우리는 이 오류들을 더 많은 대화를 통해 '판단'하고 문맥을 일치시키는 과정을 겪게됩니다.

#### 프로그래밍의 관념은 프로그래머에게

프로그래밍 역시 비슷합니다만 문제는 컴퓨터의 '해석'은 기본적으로 '개발'되는 것이지 '계발'되지 않으며 '관념'은 환경과 언어에 따라 차이를 보입니다. 가장 간단하게 말하자면 컴퓨터는 배우지 않는다고도 말씀드릴 수 있겠습니다. 아, 머신러닝 얘기하시는 분이 있겠지만 프로그래밍 언어 측면에서 아직은 아닙니다. 프로그래머가 존재하는 이유는 단지 프로그래밍 언어를 알고 있기 때문만은 아닙니다. 관념을 언어를 통해 표출할 수 있는 사고의 과정이 존재하기 때문입니다. :)

> 물론 있기만 하다면 저도 이런 것 하나 가지고 싶습니다.<br/>
> ![R2D2](http://upload.wikimedia.org/wikipedia/en/3/39/R2-D2_Droid.png)<br/>
> "R2D2, 디버깅 좀!!"


### 최초의 질문: 무엇을 위한 언어인가.

프로그래밍 언어의 세계에는 2가지의 서술 대상이 존재합니다. 하나는 프로그램을 기술하는 프로그래머, 다른 하나는 바로 프로그램이 실행될 환경입니다. 그리고 언어가 어느 쪽에 더 가까운지는 그 언어를 이해하는 관점에서도 매우 중요합니다.

#### 일반적인 언어의 분류

일반적으로 프로그래밍 언어는 하드웨어에 친화적일수록 저수준 언어(Low Level Language) 그리고 인간에 친화적일수록 고급 언어(High Level Language)라고 분류됩니다. 아래 그림은 프로그래밍 언어론을 다루는 많은 책들의 앞부분에서 쉽게 찾을 수 있는 그림입니다.

> 수준(Level)에 따른 프로그래밍 언어의 분류 - Oldschool!!!!<br/>
> ![수준(Level)에 따른 프로그래밍 언어의 분류](http://www.webopedia.com/FIG/PROG-LAN.gif)<br/>
> Source: [webopedia - programming language](http://www.webopedia.com/TERM/P/programming_language.html)

역사적으로 컴퓨터는 하드웨어가 먼저 개발되었습니다. 이때의 컴퓨터는 탄도 계산과 같은 특정 목적을 위해 사용되었으므로 범용적 소프트웨어 개발의 필요성으로 인한 이식성이나 유지보수성이 강조되지는 않았을 것이며 당연히 그 필요성은 목적에 대한 계산을 수행하는 프로그램이지 언어는 아니었을 것입니다. 즉, 이 시대에는 하드웨어의 개발과 함께 기계가 직접 실행하는 프로그래밍 방법은 이미 결정되었습니다.

> 이 거대한 장비는 슈퍼 컴퓨터가 아닙니다. :)<br/>
> ![맨체스터 마크-1](http://upload.wikimedia.org/wikipedia/en/d/d8/Manchester_Mark2.jpg)<br/>
> Source: [Wikipedia - Programming Language](http://en.wikipedia.org/wiki/Programming_language)

이 시점에서의 첫번째 질문을 다시 한번 던져 보겠습니다. 여러분이 이 시대에 살고 있었다면 그리고 이러한 시스템 환경에서 개발을 해야하는 사람들이었다면 **'어떤 것'이 필요했을까요?**

### 프로그래밍 언어는 필요에 의해서 발생한다.

프로그래밍 언어는 상당히 자연스러운 이유로 발생합니다. 가끔은 재미삼아 만들어진 아이들도 있지만 대부분의 경우 어떠한 목적에 따라 설계되는 경우가 많습니다.

#### 기계어와 어셈블리

예를 들어 어셈블리는 머신에서 실행되는 바이너리 코드를 1:1 동치 관계에 있는 간략한 문법으로 표현하여 특히 초기 컴퓨팅 환경에서 단지 읽을만하다는 점 하나로도 획기적인 발전을 가져온 발명이었습니다. 아래는 위키피디아의 [Low Level Language](http://en.wikipedia.org/wiki/Low-level_programming_language#Machine_code)에서 발췌한 내용으로 x86 머신에서 피보나치 수열을 구하는 코드를 16진수로 표현한 바이너리 코드입니다.

```
8B542408 83FA0077 06B80000 0000C383 ........ C84AEBF1 5BC3
```

> 바이너리 코드의 분석이 이 포스트의 범주에 포함되는 것은 아니므로 중간은 생략했습니다. :)

어느 것이 명령이고 어느 것이 데이터일까요? *만약 누군가가 한참 이 코드를 읽고 있는데 다른 사람이 툭 치면서 말을 걸면 인간의 초신성 폭팔을 실제로 볼 수 있을 것입니다. :)*

그래서 사람들은 어느 정도 가독성(Readability)이 보장되는 어셈블리를 만들기에 이릅니다. MASM 형태로 기술된 어셈블리 코드를 보도록 하겠습니다. :)

```
fib:
  mov edx, [esp+8]
  cmp edx, 0
  ja @f
  mov eax, 0
  ret

  ...

  @@:
  pop ebx
  ret
```

> 물론 위의 코드 역시도 자세히 살펴보는 것이 목적은 아니기 때문에 역시 중간은 생략했습니다.

위의 코드는 최소한 명령어와 데이터는 구분이 갑니다. 하지만 여전히 머신에 친화적인 형태이므로 다른 명령어 셋이나 방식을 지원하는 머신(CPU) 상에서는 또 다른 표현이 필요할 것입니다.

#### 좀 더 고수준 언어로

앞에서 살펴본 어셈블리로 인해 코드를 보다 쉽게 읽을 수는 있지만 한눈에 로직을 파악하기는 어려웠습니다. 이 때문에 선대의 많은 분들이 보다 인간적인(?) 구문으로 표현할 수 있는 언어들을 만들어 내기에 이릅니다. 위와 동일한 기능을 하는 C 코드를 살펴보도록 하겠습니다.

```c
unsigned int fib(unsigned int n)
{
    if (n <= 0)
        return 0;
    else if (n <= 2)
        return 1;
    else {
        int a,b,c;
        a = 1;
        b = 1;
        while (true) {
            c = a + b;
            if (n <= 3) return c;
            a = b;
            b = c;
            n--;
        }
    }
}
```

어떻습니까? **훨씬 더 읽기가 편해졌습니다**. 물론 이러한 고수준 언어는 플랫폼에 독립적인 특성 또한 지니고 있으므로 단지 읽기가 좋은 것 이외에도 도구와 라이브러리의 지원을 통해 많은 플랫폼에 대한 실행 바이너리를 비교적 손쉽게 옮길 수도 있습니다.

### 물론 일반적인 학습 방법이 더 효율적일 수 있다.

이와 같이 언어의 발생 과정을 유추하면 어떤 필요성에 의해 개발되고 발전되어 온 것을 알 수 있습니다만, 우리가 학습을 진행하며 만나는 과정은 살펴본 순서와는 반대입니다. 이는 당연한 일이기도 합니다. 우리가 영어를 배우기 위해 문장 구조, 역사 등을 학습하는 것은 분명 도움이 되겠지만 효율적이라고 하기는 어렵습니다.

같은 관점에서 프로그래밍 언어 역시 언어가 발생한 배경이나 토대를 귀납적으로 풀어가는 과정이 빠르게 언어를 익히는데는 장애물이 될 수도 있습니다. 더불어 하드웨어나 어셈블리 혹은 기계어까지 내려가지 않아도 추상적인 개념화를 통해 C와 같은 언어를 충분히 학습할 수 있고 사용할 수도 있는데 굳이 시간과 노력을 들일 필요는 없을 수도 있습니다.

### 언어의 각 특성의 원인(필요성) 찾아내기

그러나 언어의 대상이 `프로그래머`와 `환경` 두가지를 모두 포함한다는 관점 하에서, 우리로부터 출발하는, 그러니까 `프로그래머` 관점의 이해도 중요하지만 가능하면 `환경`으로부터 출발하는 사고의 과정을 동시에 진행하는 것이 유리합니다.

위에서 설명했던 예처럼 `기계어`로 표출된 코드를 좀 더 사용자가 쉽게 이해할 수 있도록 하기 위해 `어셈블리`가 고안되었고 타겟 머신에 의존적이지 않으며 보다 일반적인 코드의 서술을 위해 `C`와 같은 고수준의 언어가 정의되었다고 우리는 생각해볼 수 있습니다. 혹은 우리가 반대로 처리한 결과 역시 그렇습니다.

간단하게 위의 접근 방법 2가지는 다음과 같습니다. 첫번째는 흐름에 따른 접근입니다.

1. C
	* *컴파일을 통해 해석되어 목적 코드를 생성*
2. 목적 코드(e.g. 어셈블리)
	* 링커를 통해 결합하여
3. 실행 바이너리

물론 두번째는 필요성에 의한 접근입니다.

1. 실행 바이너리 형태
    * **읽기 어렵다**.
2. 어셈블리
    * **기호(mnemonics) 형태로 표현했지만 로직을 파악하기 힘들다**.
3. C
    * **서술 표현**

이와는 별개로 `객체` 간의 상호작용을 기반으로 프로그램을 작성해야 한다는 필요성은 객체 지향이라는 개념을 다루는 `Smalltalk`, `C++`, `Java` 등의 언어가 발생시켰습니다.

> 참고로 객체지향 언어가 이후에 나왔다는 뜻은 아닙니다. 객체 지향에 대한 개념은 컴퓨팅 언어의 역사에서도 굉장히 빠르게 나온 개념이고 이를 구체화한 언어도 50년대에 이미 개발된 상태였습니다.

발생 과정의 역순 그러니까 필요성의 관점에서 언어의 특질을 이해하는 부분은 이와 같은 이유로 필요합니다.

### 실제적인 프로그래밍 언어의 파악

프로그래밍 언어의 목적은 다양하지만 밑으로 내려가고 내려가고 하다보면 결국 그 목적을 위해 `데이터`를 다루는 방법인 `명령어`로 귀결됩니다.

### 가장 좋은 시작점: Type

프로그래밍 언어 책의 앞 부분에는 항상 '형(Type)'이 존재합니다. 앞 부분에 존재하는 것은 기초이기 때문일 수도 있고 중요할 수도 있겠지만 제 관점에서는 둘 다입니다.

## 언어와 약속의 공통점

### 포병의 숫자세기

최근에 방영 중인 모 예능 방송에서 `포병의 숫자`에 대한 에피소드가 나온다.

 > "하나, 둘, 삼, 넷, 오, 여섯, 칠, 팔, 아홉, 공! 으잉???"

포병의 숫자 세기는 포격 소리로 말이 잘 들리지 않는 `셋`과 `넷`이 혼동될 수 있기 때문에

## 공부해야 할 것이 많은 것은 당연합니다.

### 결국 프로그래밍 언어는 `수단`이고 `도구`일 뿐, 그 이상도 그 이하도 아닙니다.

물론 여타의 이유로 인해 `언어` 그 자체를 개발해야 하는 일도 비일비재하지만 일반적인 경우 이것이 프로그래밍을 하는 주 목적은 아닙니다.
